<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Rendering</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #000000;
            overflow: hidden;
        }
    </style>
    <script src="lib/gl-matrix.js"></script>
    <script src="lib/picogl.js"></script>
</head>
<body>
    <canvas id="gl-canvas"></canvas>

    <script type="x-shader/x-vertex" id="vertexShader">
        #version 300 es

        uniform mat4 modelViewMatrix;
        uniform mat4 modelViewProjectionMatrix;

        layout(location=0) in vec3 position;
        layout(location=1) in vec3 normal;

        out vec4 color;

        void main()
        {
            gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
            vec3 norm = (modelViewMatrix * vec4(normal, 0.0)).xyz;
            color = mix(vec4(1.0, 0.2, 0.3, 1.0) * 0.8, vec4(1.0, 0.9, 0.5, 1.0), norm.z) + pow(norm.z, 20.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        #version 300 es
        precision highp float;

        in vec4 color;

        out vec4 outColor;

        void main()
        {
            outColor = color;
        }
    </script>

    <script type="text/javascript">
        let positions = new Float32Array([
            // front
            -0.5, 0.5, 0.5,
            0.5, 0.5, 0.5,
            0.5, -0.5, 0.5,
            -0.5, -0.5, 0.5,

            // back
            -0.5, 0.5, -0.5,
            0.5, 0.5, -0.5,
            0.5, -0.5, -0.5,
            -0.5, -0.5, -0.5,

            //top
            -0.5, 0.5, 0.5,
            0.5, 0.5, 0.5,
            0.5, 0.5, -0.5,
            -0.5, 0.5, -0.5,

            //bottom
            -0.5, -0.5, 0.5,
            0.5, -0.5, 0.5,
            0.5, -0.5, -0.5,
            -0.5, -0.5, -0.5,

            //left
            -0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            -0.5, -0.5, -0.5,

            //right
            0.5, -0.5, 0.5,
            0.5, 0.5, 0.5,
            0.5, 0.5, -0.5,
            0.5, -0.5, -0.5,
        ]);

        let normals = new Float32Array([
            // front
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,

            // back
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            //top
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,

            //bottom
            0.0, -1.0, 0.0,
            0.0, -1.0, 0.0,
            0.0, -1.0, 0.0,
            0.0, -1.0, 0.0,

            //left
            -1.0, 0.0, 0.0,
            -1.0, 0.0, 0.0,
            -1.0, 0.0, 0.0,
            -1.0, 0.0, 0.0,

            //right
            1.0, 0.0, 0.0,
            1.0, 0.0, 0.0,
            1.0, 0.0, 0.0,
            1.0, 0.0, 0.0,
        ]);

        let triangles = new Uint16Array([
            // front
            2, 1, 0,
            0, 3, 2,

            // back
            4, 5, 6,
            6, 7, 4,

            // top
            8, 9, 10,
            10, 11, 8,

            // bottom
            14, 13, 12,
            12, 15, 14,

            // left
            16, 17, 18,
            18, 19, 16,

            // right
            22, 21, 20,
            20, 23, 22,
        ]);

        let canvas = document.getElementById("gl-canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let app = PicoGL.createApp(canvas)
            .clearColor(1.0, 0.2, 0.3, 1.0)
            // .depthTest();
            .cullBackfaces();

        window.onresize = function() {
            app.resize(window.innerWidth, window.innerHeight);
        };

        let program = app.createProgram(document.getElementById("vertexShader").text.trim(), document.getElementById("fragmentShader").text.trim());

        let vertexArray = app.createVertexArray()
            .vertexAttributeBuffer(0, app.createVertexBuffer(PicoGL.FLOAT, 3, positions))
            .vertexAttributeBuffer(1, app.createVertexBuffer(PicoGL.FLOAT, 3, normals))
            .indexBuffer(app.createIndexBuffer(PicoGL.UNSIGNED_SHORT, 3, triangles));

        var projMatrix = mat4.create();
        var viewMatrix = mat4.create();
        var viewProjMatrix = mat4.create();
        var modelMatrix = mat4.create();
        var modelViewMatrix = mat4.create();
        var modelViewProjectionMatrix = mat4.create();
        var rotateXMatrix = mat4.create();
        var rotateYMatrix = mat4.create();

        var modelViewMatrix2 = mat4.create();
        var modelViewProjectionMatrix2 = mat4.create();

        var drawCall = app.createDrawCall(program, vertexArray);
        // var drawCall2 = app.createDrawCall(program, vertexArray);

        var startTime = new Date().getTime() / 1000;
        function draw() {
            let time = new Date().getTime() / 1000 - startTime;

            mat4.perspective(projMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
            mat4.lookAt(viewMatrix, vec3.fromValues(3, 2, 2), vec3.fromValues(0, 0, 0), vec3.fromValues(0, 1, 0));
            mat4.multiply(viewProjMatrix, projMatrix, viewMatrix);

            mat4.fromXRotation(rotateXMatrix, time * 0.1136);
            mat4.fromYRotation(rotateYMatrix, time * 0.2235);
            mat4.multiply(modelMatrix, rotateXMatrix, rotateYMatrix);

            mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
            mat4.multiply(modelViewProjectionMatrix, viewProjMatrix, modelMatrix);

            drawCall.uniform("modelViewMatrix", modelViewMatrix);
            drawCall.uniform("modelViewProjectionMatrix", modelViewProjectionMatrix);

            mat4.fromTranslation(modelMatrix, vec3.fromValues(0, 0, 0));
            mat4.multiply(modelViewMatrix2, viewMatrix, modelMatrix);
            mat4.multiply(modelViewProjectionMatrix2, viewProjMatrix, modelMatrix);

            // drawCall2.uniform("modelViewMatrix", modelViewMatrix2);
            // drawCall2.uniform("modelViewProjectionMatrix", modelViewProjectionMatrix2);

            app.clear();
            drawCall.draw();
            // drawCall2.draw();

            requestAnimationFrame(draw);
        }
        requestAnimationFrame(draw);
    </script>
</body>
</html>